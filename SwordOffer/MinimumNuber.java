//////////////
import java.util.ArrayList;
public class Solution {
    public int minNumberInRotateArray(int [] array) {
        int len = array.length;
        if(len == 0){
            return 0;
        }
        int left = 0;
        int right = len - 1;
        while(true){
            int mid = (left + right) / 2;
            if(array[mid] > array[left]){
                left = mid;
            }
            else if(array[mid] < array[left]){
                right = mid;
            }
            else{
                if(array[left] > array[right]){
                    return array[right];
                }
                else{
                    return array[left];
                }
            }
        }
    }
}

##题目描述##
##把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 
##输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 
##例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 
##NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。

##算法思路##
这道题就是简单的二分查找算法，题目给出的非减排序数组，也就是说不是严格递增.

思路：

（1）我们用两个指针left,right分别指向数组的第一个元素和最后一个元素。按照题目的旋转的规则，第一个元素应该是大于最后一个元素的（没有重复的元素）。

但是如果不是旋转，第一个元素肯定小于最后一个元素。

（2）找到数组的中间元素。

中间元素大于第一个元素，则中间元素位于前面的递增子数组，此时最小元素位于中间元素的后面。我们可以让第一个指针left指向中间元素。

移动之后，第一个指针仍然位于前面的递增数组中。

中间元素小于第一个元素，则中间元素位于后面的递增子数组，此时最小元素位于中间元素的前面。我们可以让第二个指针right指向中间元素。

移动之后，第二个指针仍然位于后面的递增数组中。

这样可以缩小寻找的范围。

（3）按照以上思路，第一个指针left总是指向前面递增数组的元素，第二个指针right总是指向后面递增的数组元素。

最终第一个指针将指向前面数组的最后一个元素，第二个指针指向后面数组中的第一个元素。

也就是说他们将指向两个相邻的元素，而第二个指针指向的刚好是最小的元素，这就是循环的结束条件。

